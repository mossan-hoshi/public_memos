# コンピューターアーキテクチャ
- 方針：まぁとりあえずパタヘネを全部やっとけば問題なかろう
■パターソン＆ヘネシー「コンピューターの構成と設
# ＝＝＝＝上巻、始まるよ＝＝＝＝＝
## 4.5 パイプライン処理の概要
- MIPSはパイプライン化を意識している命令セット
    - 全て同じ命令長。だから、ステージを組みやすい
        - ちなみにx86系は命令長が1～17バイトなのでパイプライン化しにくい
            - というわけで一旦同じ命令長のマイクロ命令に変換してパイプライン化している
    - 全命令の**ソースのフィールド位置が同じ**
- **メモリ・オペランドはロードまたはストアにのみ現れる**
    - パイプラインハザード
    - ３種類
        - 構造ハザード：命令の組み合わせにHWが対応できない場合。例えれば全自動洗濯機
    - データハザード：前の命令の出力データを待つ場合。
                            この場合、命令を一時停止するストールを実行する必要あり。
                        - 対策として演算データができ次第ALU内で出力から入力に持ってくる等
                特殊なデータパスを作るフォワーディング\(バイパシング\)という手法がある
        - 制御ハザード：分岐のあとの処理など。
## 4.10 並列処理と高度砿命令レベル並列性
- 投機実行
    - 分岐時や結果依存のない連続命令の時などに後の命令を
        先読みして実行することで効率を上げる技術
        - SW\(コンパイラ\)・HWどちらでも実装可能
        - SW:
        - 外れていた場合のために「当たったかのチェック」と「外れた場合の復帰機構」
        が必要
    - SW：【チェック方法】チェック用の追加命令挿入
                【復帰方法】チェック方法で外れていた時に入る復帰ルーチン追加
                - HW：投機実行結果をバッファに保持しておいて、
                当たっていたらバッファをメモリに書き込み、
                外れていたらバッファをフラッシュ
        - 投機実行は追加の命令が入るため、そこで例外が発生してしまう事がある。
        そのような例外は本来起こりえない例外なので、無視する必要がある。
    - SW：専用のサポート機能で、投機実行中の例外を無視
            HW：例外をバッファに保持しておいて、結果に応じて例外を実行or破棄
        - **静的な複数命令発行**
    - 静的な複数命令発行プロセッサでは、１まとまりの複数の命令\(発行パケット\)
        ごとに処理する。
        - 例えば2命令\(算術演算＋データ転送命令\)を同時実行するようなプロセッサでは
        追加のハードとして「レジスタファイル用の新規ポート」と
    「データ転送アドレス演算用のALU」を加える事で同時実行が可能となる\(P366\)
    - とは言え、ステージの構成等をちゃんと考えて設計しないと効率は上がらない。
        - ループの処理効率改善のために「ループ展開\(loop unrolling\)」という手法がある。
        - ここらへんはSystemCとかでもおなじみですな。

# ＝＝＝＝以下、下巻＝＝＝＝＝＝＝
              容量と速度の両立:記憶階層の利用
## 5.1 はじめに418
- 理想は無限大の容量と速度を持つメモリだけど現実はむりぽアクセス速度の違い    価格の違い
    - S    AM⇔    RAM    ２桁レ    で違う    2桁レベルで違う
        -      AM     DD     ５桁レ    で違う    2桁レベルで違う
            -       D⇔      D       数倍    ルの違い    数倍レベルの違い
## 5.2 キャッシュの基礎423
- 【こぼれ話】同じSRAMのキャッシュでも最近では**CPUに近い順に３種類\(L1/L2/L3\)の格付け**がなされている。参考までに[Intel Core i7\-4770](http://www.cpu-world.com/CPUs/Core_i7/Intel-Core%20i7-4770.html)のキャッシュのサイズはこんな感じ
- L1 キャッシュ：命令キャッシュ128KB\(4x32KB\)、データキャッシュ128KB\(4x32KB\)
- L2 キャッシュ：1MB\(4x256KB\)
- L3 キャッシュ：8MB共有キャッシュ
    - キャッシュメモリはデータをライン\(ブロック\)と呼ぶ
    ある程度まとまった単位で管理する
- IntelではPen4時代から最新のi7\-4770まで変わらずブロックサイズ**64Byte**
        - ただし、4770のキャッシュは２スレッド構成
### ダイレクトマップ方式\(Direct Mapped\)
- メモリの番地ごとに対応するキャッシュの番地を設定。
    ◇Good\(・∀・\)ｲｲﾈ\!\!
    - アドレス周りの計算が楽
        - キャッシュのアドレスがnビットでメモリのアドレスがmビットの場合、
            メモリのアドレスの下位nビットを引っ張ってくるだけで対応する
        キャッシュのアドレスが算出できる
            - また、キャッシュ内のデータが対応するメモリアドレスについても
            上位n\-mビットだけ保持しておけば良いので、データ効率も良い
        - 一応ゴミデータが入ってる場合もあるので、有効フラグで
                ちゃんとメモリに対応したデータかどうかを示してやる
    ◇Bad\(ヽ´ω\`\)
    - キャッシュの長さが2^nになる必要がある。
        - そうでないとアドレス関連で楽できない
        - 方式的に一番簡単だけど
    
#### セットアソシアティブ方式 \(Set Associative\)
#### フルアソシアティブ方式 \(Fully Associative\)
## 5.3 キャッシュの性能の測定と改善439
## 5.4 仮想記憶455
## 5.5 記憶階層聞に共通する概念480
## 5.6 仮想マシン487
## 5.7 有限状態機械を用いた単純なキャッシユの制御491
## 5.8 並列処理と記憶階層:キャッシユ・コヒーレンス496
## 7.2 並列処理プログラム作成の困難さ
- 処理に前後関係が存在すると処理待ちが発生し効率が低下する![088f5309-f5b7-49fd-9c95-2df1e74e0cd4.png](image/088f5309-f5b7-49fd-9c95-2df1e74e0cd4.png)
（※）\(改善の\)影響をうける時間の～
- プロセッサの数が増えても改善の影響を受けない実行時間は変わらないため、一定の数以上のプロセッサになると今度はプロセッサあたりの改善率は低下する
## 7.3 共有記憶型マルチプロセッサ\(P598\)
- 共有記憶型マルチプロセッサ\(sharedmemory multiprocessor: SMP
- 一番わかり易いマルチプロセッシングシステム
- メモリにアクセスするプロセッサによってアクセス時間が異なるかどうかで分かれる
    - 均等メモリ・アクセス\(UMA\)
- 非均等メモリ・アクセス\(NUMA\)
    - 書き込みや読み込みには調停（同期）が必要
    - 書き込み中はロックをかける等
    - 
## 7.4 クラスタおよびその他のメッセージ交換型マルチプロセッサ
### クラスタ
- SMPとは違って、プロセッサごとに独立のメモリ空間を保つ場合、
    クラスタが主流
    - クラスタではプロセッサ間でメッセージ交換\(messagepassing\)を通じて情報を交換
    - メッセージ送信ルーチン\(sendmessage routine\)
- メッセージ受信ルーチン\(receive message routine\)
- どちらのルーチンでもメッセージ受け取ったプロセッサはACKを返す
    - クラスタの短所
    - 仮想マシンに比べて管理コストが大きい
- マルチコアマシンに比べてバンド幅・レイテンシがしょぼい
- 主記憶を分割することでオーバーヘッドが大きい
    - クラスタの長所
    - アベイラビリティの高さ
### グリッドコンピューティング
    - SETIなどの遠距離ネットワーク経由の計算システム
## 7.5 ハードウエア・マルチスレッデインタ
- レジスタ、
    - メモリは共有
    - 超早く切り替える必要がある
          ・マルチスレッディングの手法は主に２通り
- 細粒度マルチスレッディング\(fine\-grained multi threading\)
         - 命令単位でスレッドを切り替えて交互に実行する方法
     - スレッドごとにパイプライン化が可能になる
   ・組粒度マルチスレッディング\(coarse\-grained multi threading\)
  - 長時間のストール\(命令データ待ち状態\)が発生しない限りスレッド切り替えを行わない
         - 同時マルチスレッデイング\(simultaneousmultithreading : SMT\)
         - 同時マルチスレッデイング\(simultaneousmultithreading : SMT\)
 - スーパースカラのマルチスレッドによる効率化の例
     - マルチスレッドなしだと、発行スロットの日効率化＆ストールへの対応が無い
 - 粗粒度だと大きなストールの時にスレッドBに切り替えて多少は効率化
 - 細粒度だと舞いサイクル切り替えてストールをかなり改善
 - 同時マルチ～だと、ギュウギュウに埋めて効率化
